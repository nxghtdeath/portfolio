/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
(function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

    // Exported root namespace
    var $root = $protobuf.roots["push-server"] || ($protobuf.roots["push-server"] = {});

    $root.RequestBatch = (function() {

        /**
         * Properties of a RequestBatch.
         * @exports IRequestBatch
         * @interface IRequestBatch
         * @property {Array.<Request>|null} [requests] RequestBatch requests
         */

        /**
         * Constructs a new RequestBatch.
         * @exports RequestBatch
         * @classdesc Represents a RequestBatch.
         * @implements IRequestBatch
         * @constructor
         * @param {IRequestBatch=} [properties] Properties to set
         */
        function RequestBatch(properties) {
            this.requests = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestBatch requests.
         * @member {Array.<Request>} requests
         * @memberof RequestBatch
         * @instance
         */
        RequestBatch.prototype.requests = $util.emptyArray;

        /**
         * Creates a new RequestBatch instance using the specified properties.
         * @function create
         * @memberof RequestBatch
         * @static
         * @param {IRequestBatch=} [properties] Properties to set
         * @returns {RequestBatch} RequestBatch instance
         */
        RequestBatch.create = function create(properties) {
            return new RequestBatch(properties);
        };

        /**
         * Encodes the specified RequestBatch message. Does not implicitly {@link RequestBatch.verify|verify} messages.
         * @function encode
         * @memberof RequestBatch
         * @static
         * @param {RequestBatch} message RequestBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestBatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requests != null && message.requests.length)
                for (var i = 0; i < message.requests.length; ++i)
                    $root.Request.encode(message.requests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a RequestBatch message from the specified reader or buffer.
         * @function decode
         * @memberof RequestBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RequestBatch} RequestBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestBatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RequestBatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.requests && message.requests.length))
                        message.requests = [];
                    message.requests.push($root.Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RequestBatch;
    })();

    $root.Request = (function() {

        /**
         * Properties of a Request.
         * @exports IRequest
         * @interface IRequest
         * @property {IncomingMessagesRequest|null} [incomingMessages] Request incomingMessages
         * @property {ChannelStatsRequest|null} [channelStats] Request channelStats
         * @property {ServerStatsRequest|null} [serverStats] Request serverStats
         */

        /**
         * Constructs a new Request.
         * @exports Request
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request incomingMessages.
         * @member {IncomingMessagesRequest|null|undefined} incomingMessages
         * @memberof Request
         * @instance
         */
        Request.prototype.incomingMessages = null;

        /**
         * Request channelStats.
         * @member {ChannelStatsRequest|null|undefined} channelStats
         * @memberof Request
         * @instance
         */
        Request.prototype.channelStats = null;

        /**
         * Request serverStats.
         * @member {ServerStatsRequest|null|undefined} serverStats
         * @memberof Request
         * @instance
         */
        Request.prototype.serverStats = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Request command.
         * @member {"incomingMessages"|"channelStats"|"serverStats"|undefined} command
         * @memberof Request
         * @instance
         */
        Object.defineProperty(Request.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["incomingMessages", "channelStats", "serverStats"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Request
         * @static
         * @param {IRequest=} [properties] Properties to set
         * @returns {Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Request.verify|verify} messages.
         * @function encode
         * @memberof Request
         * @static
         * @param {Request} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.incomingMessages != null && message.hasOwnProperty("incomingMessages"))
                $root.IncomingMessagesRequest.encode(message.incomingMessages, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelStats != null && message.hasOwnProperty("channelStats"))
                $root.ChannelStatsRequest.encode(message.channelStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.serverStats != null && message.hasOwnProperty("serverStats"))
                $root.ServerStatsRequest.encode(message.serverStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.incomingMessages = $root.IncomingMessagesRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.channelStats = $root.ChannelStatsRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.serverStats = $root.ServerStatsRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Request;
    })();

    $root.IncomingMessagesRequest = (function() {

        /**
         * Properties of an IncomingMessagesRequest.
         * @exports IIncomingMessagesRequest
         * @interface IIncomingMessagesRequest
         * @property {Array.<IncomingMessage>|null} [messages] IncomingMessagesRequest messages
         */

        /**
         * Constructs a new IncomingMessagesRequest.
         * @exports IncomingMessagesRequest
         * @classdesc Represents an IncomingMessagesRequest.
         * @implements IIncomingMessagesRequest
         * @constructor
         * @param {IIncomingMessagesRequest=} [properties] Properties to set
         */
        function IncomingMessagesRequest(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingMessagesRequest messages.
         * @member {Array.<IncomingMessage>} messages
         * @memberof IncomingMessagesRequest
         * @instance
         */
        IncomingMessagesRequest.prototype.messages = $util.emptyArray;

        /**
         * Creates a new IncomingMessagesRequest instance using the specified properties.
         * @function create
         * @memberof IncomingMessagesRequest
         * @static
         * @param {IIncomingMessagesRequest=} [properties] Properties to set
         * @returns {IncomingMessagesRequest} IncomingMessagesRequest instance
         */
        IncomingMessagesRequest.create = function create(properties) {
            return new IncomingMessagesRequest(properties);
        };

        /**
         * Encodes the specified IncomingMessagesRequest message. Does not implicitly {@link IncomingMessagesRequest.verify|verify} messages.
         * @function encode
         * @memberof IncomingMessagesRequest
         * @static
         * @param {IncomingMessagesRequest} message IncomingMessagesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingMessagesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.IncomingMessage.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an IncomingMessagesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof IncomingMessagesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {IncomingMessagesRequest} IncomingMessagesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingMessagesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IncomingMessagesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.IncomingMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return IncomingMessagesRequest;
    })();

    $root.IncomingMessage = (function() {

        /**
         * Properties of an IncomingMessage.
         * @exports IIncomingMessage
         * @interface IIncomingMessage
         * @property {Array.<Receiver>|null} [receivers] IncomingMessage receivers
         * @property {Sender|null} [sender] IncomingMessage sender
         * @property {string|null} [body] IncomingMessage body
         * @property {number|null} [expiry] IncomingMessage expiry
         * @property {string|null} [type] IncomingMessage type
         */

        /**
         * Constructs a new IncomingMessage.
         * @exports IncomingMessage
         * @classdesc Represents an IncomingMessage.
         * @implements IIncomingMessage
         * @constructor
         * @param {IIncomingMessage=} [properties] Properties to set
         */
        function IncomingMessage(properties) {
            this.receivers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingMessage receivers.
         * @member {Array.<Receiver>} receivers
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.receivers = $util.emptyArray;

        /**
         * IncomingMessage sender.
         * @member {Sender|null|undefined} sender
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.sender = null;

        /**
         * IncomingMessage body.
         * @member {string} body
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.body = "";

        /**
         * IncomingMessage expiry.
         * @member {number} expiry
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.expiry = 0;

        /**
         * IncomingMessage type.
         * @member {string} type
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.type = "";

        /**
         * Creates a new IncomingMessage instance using the specified properties.
         * @function create
         * @memberof IncomingMessage
         * @static
         * @param {IIncomingMessage=} [properties] Properties to set
         * @returns {IncomingMessage} IncomingMessage instance
         */
        IncomingMessage.create = function create(properties) {
            return new IncomingMessage(properties);
        };

        /**
         * Encodes the specified IncomingMessage message. Does not implicitly {@link IncomingMessage.verify|verify} messages.
         * @function encode
         * @memberof IncomingMessage
         * @static
         * @param {IncomingMessage} message IncomingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.receivers != null && message.receivers.length)
                for (var i = 0; i < message.receivers.length; ++i)
                    $root.Receiver.encode(message.receivers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sender != null && message.hasOwnProperty("sender"))
                $root.Sender.encode(message.sender, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.body != null && message.hasOwnProperty("body"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.body);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expiry);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.type);
            return writer;
        };

        /**
         * Decodes an IncomingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof IncomingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {IncomingMessage} IncomingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IncomingMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.receivers && message.receivers.length))
                        message.receivers = [];
                    message.receivers.push($root.Receiver.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.sender = $root.Sender.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.body = reader.string();
                    break;
                case 4:
                    message.expiry = reader.uint32();
                    break;
                case 5:
                    message.type = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return IncomingMessage;
    })();

    $root.ChannelStatsRequest = (function() {

        /**
         * Properties of a ChannelStatsRequest.
         * @exports IChannelStatsRequest
         * @interface IChannelStatsRequest
         * @property {Array.<ChannelId>|null} [channels] ChannelStatsRequest channels
         */

        /**
         * Constructs a new ChannelStatsRequest.
         * @exports ChannelStatsRequest
         * @classdesc Represents a ChannelStatsRequest.
         * @implements IChannelStatsRequest
         * @constructor
         * @param {IChannelStatsRequest=} [properties] Properties to set
         */
        function ChannelStatsRequest(properties) {
            this.channels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStatsRequest channels.
         * @member {Array.<ChannelId>} channels
         * @memberof ChannelStatsRequest
         * @instance
         */
        ChannelStatsRequest.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ChannelStatsRequest instance using the specified properties.
         * @function create
         * @memberof ChannelStatsRequest
         * @static
         * @param {IChannelStatsRequest=} [properties] Properties to set
         * @returns {ChannelStatsRequest} ChannelStatsRequest instance
         */
        ChannelStatsRequest.create = function create(properties) {
            return new ChannelStatsRequest(properties);
        };

        /**
         * Encodes the specified ChannelStatsRequest message. Does not implicitly {@link ChannelStatsRequest.verify|verify} messages.
         * @function encode
         * @memberof ChannelStatsRequest
         * @static
         * @param {ChannelStatsRequest} message ChannelStatsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStatsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (var i = 0; i < message.channels.length; ++i)
                    $root.ChannelId.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ChannelStatsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStatsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStatsRequest} ChannelStatsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStatsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStatsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.ChannelId.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStatsRequest;
    })();

    $root.ChannelId = (function() {

        /**
         * Properties of a ChannelId.
         * @exports IChannelId
         * @interface IChannelId
         * @property {Uint8Array|null} [id] ChannelId id
         * @property {boolean|null} [isPrivate] ChannelId isPrivate
         * @property {Uint8Array|null} [signature] ChannelId signature
         */

        /**
         * Constructs a new ChannelId.
         * @exports ChannelId
         * @classdesc Represents a ChannelId.
         * @implements IChannelId
         * @constructor
         * @param {IChannelId=} [properties] Properties to set
         */
        function ChannelId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelId id.
         * @member {Uint8Array} id
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.id = $util.newBuffer([]);

        /**
         * ChannelId isPrivate.
         * @member {boolean} isPrivate
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.isPrivate = false;

        /**
         * ChannelId signature.
         * @member {Uint8Array} signature
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new ChannelId instance using the specified properties.
         * @function create
         * @memberof ChannelId
         * @static
         * @param {IChannelId=} [properties] Properties to set
         * @returns {ChannelId} ChannelId instance
         */
        ChannelId.create = function create(properties) {
            return new ChannelId(properties);
        };

        /**
         * Encodes the specified ChannelId message. Does not implicitly {@link ChannelId.verify|verify} messages.
         * @function encode
         * @memberof ChannelId
         * @static
         * @param {ChannelId} message ChannelId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
            return writer;
        };

        /**
         * Decodes a ChannelId message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelId} ChannelId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelId;
    })();

    $root.ServerStatsRequest = (function() {

        /**
         * Properties of a ServerStatsRequest.
         * @exports IServerStatsRequest
         * @interface IServerStatsRequest
         */

        /**
         * Constructs a new ServerStatsRequest.
         * @exports ServerStatsRequest
         * @classdesc Represents a ServerStatsRequest.
         * @implements IServerStatsRequest
         * @constructor
         * @param {IServerStatsRequest=} [properties] Properties to set
         */
        function ServerStatsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ServerStatsRequest instance using the specified properties.
         * @function create
         * @memberof ServerStatsRequest
         * @static
         * @param {IServerStatsRequest=} [properties] Properties to set
         * @returns {ServerStatsRequest} ServerStatsRequest instance
         */
        ServerStatsRequest.create = function create(properties) {
            return new ServerStatsRequest(properties);
        };

        /**
         * Encodes the specified ServerStatsRequest message. Does not implicitly {@link ServerStatsRequest.verify|verify} messages.
         * @function encode
         * @memberof ServerStatsRequest
         * @static
         * @param {ServerStatsRequest} message ServerStatsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerStatsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a ServerStatsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ServerStatsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServerStatsRequest} ServerStatsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerStatsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerStatsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ServerStatsRequest;
    })();

    $root.Sender = (function() {

        /**
         * Properties of a Sender.
         * @exports ISender
         * @interface ISender
         * @property {SenderType|null} [type] Sender type
         * @property {Uint8Array|null} [id] Sender id
         */

        /**
         * Constructs a new Sender.
         * @exports Sender
         * @classdesc Represents a Sender.
         * @implements ISender
         * @constructor
         * @param {ISender=} [properties] Properties to set
         */
        function Sender(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Sender type.
         * @member {SenderType} type
         * @memberof Sender
         * @instance
         */
        Sender.prototype.type = 0;

        /**
         * Sender id.
         * @member {Uint8Array} id
         * @memberof Sender
         * @instance
         */
        Sender.prototype.id = $util.newBuffer([]);

        /**
         * Creates a new Sender instance using the specified properties.
         * @function create
         * @memberof Sender
         * @static
         * @param {ISender=} [properties] Properties to set
         * @returns {Sender} Sender instance
         */
        Sender.create = function create(properties) {
            return new Sender(properties);
        };

        /**
         * Encodes the specified Sender message. Does not implicitly {@link Sender.verify|verify} messages.
         * @function encode
         * @memberof Sender
         * @static
         * @param {Sender} message Sender message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Sender.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id);
            return writer;
        };

        /**
         * Decodes a Sender message from the specified reader or buffer.
         * @function decode
         * @memberof Sender
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Sender} Sender
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Sender.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Sender();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Sender;
    })();

    /**
     * SenderType enum.
     * @exports SenderType
     * @enum {string}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} CLIENT=1 CLIENT value
     * @property {number} BACKEND=2 BACKEND value
     */
    $root.SenderType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "CLIENT"] = 1;
        values[valuesById[2] = "BACKEND"] = 2;
        return values;
    })();

    $root.Receiver = (function() {

        /**
         * Properties of a Receiver.
         * @exports IReceiver
         * @interface IReceiver
         * @property {Uint8Array|null} [id] Receiver id
         * @property {boolean|null} [isPrivate] Receiver isPrivate
         * @property {Uint8Array|null} [signature] Receiver signature
         */

        /**
         * Constructs a new Receiver.
         * @exports Receiver
         * @classdesc Represents a Receiver.
         * @implements IReceiver
         * @constructor
         * @param {IReceiver=} [properties] Properties to set
         */
        function Receiver(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Receiver id.
         * @member {Uint8Array} id
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.id = $util.newBuffer([]);

        /**
         * Receiver isPrivate.
         * @member {boolean} isPrivate
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.isPrivate = false;

        /**
         * Receiver signature.
         * @member {Uint8Array} signature
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new Receiver instance using the specified properties.
         * @function create
         * @memberof Receiver
         * @static
         * @param {IReceiver=} [properties] Properties to set
         * @returns {Receiver} Receiver instance
         */
        Receiver.create = function create(properties) {
            return new Receiver(properties);
        };

        /**
         * Encodes the specified Receiver message. Does not implicitly {@link Receiver.verify|verify} messages.
         * @function encode
         * @memberof Receiver
         * @static
         * @param {Receiver} message Receiver message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Receiver.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
            return writer;
        };

        /**
         * Decodes a Receiver message from the specified reader or buffer.
         * @function decode
         * @memberof Receiver
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Receiver} Receiver
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Receiver.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Receiver();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Receiver;
    })();

    $root.ResponseBatch = (function() {

        /**
         * Properties of a ResponseBatch.
         * @exports IResponseBatch
         * @interface IResponseBatch
         * @property {Array.<Response>|null} [responses] ResponseBatch responses
         */

        /**
         * Constructs a new ResponseBatch.
         * @exports ResponseBatch
         * @classdesc Represents a ResponseBatch.
         * @implements IResponseBatch
         * @constructor
         * @param {IResponseBatch=} [properties] Properties to set
         */
        function ResponseBatch(properties) {
            this.responses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseBatch responses.
         * @member {Array.<Response>} responses
         * @memberof ResponseBatch
         * @instance
         */
        ResponseBatch.prototype.responses = $util.emptyArray;

        /**
         * Creates a new ResponseBatch instance using the specified properties.
         * @function create
         * @memberof ResponseBatch
         * @static
         * @param {IResponseBatch=} [properties] Properties to set
         * @returns {ResponseBatch} ResponseBatch instance
         */
        ResponseBatch.create = function create(properties) {
            return new ResponseBatch(properties);
        };

        /**
         * Encodes the specified ResponseBatch message. Does not implicitly {@link ResponseBatch.verify|verify} messages.
         * @function encode
         * @memberof ResponseBatch
         * @static
         * @param {ResponseBatch} message ResponseBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseBatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.responses != null && message.responses.length)
                for (var i = 0; i < message.responses.length; ++i)
                    $root.Response.encode(message.responses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ResponseBatch message from the specified reader or buffer.
         * @function decode
         * @memberof ResponseBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ResponseBatch} ResponseBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseBatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResponseBatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.responses && message.responses.length))
                        message.responses = [];
                    message.responses.push($root.Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ResponseBatch;
    })();

    $root.Response = (function() {

        /**
         * Properties of a Response.
         * @exports IResponse
         * @interface IResponse
         * @property {OutgoingMessagesResponse|null} [outgoingMessages] Response outgoingMessages
         * @property {ChannelStatsResponse|null} [channelStats] Response channelStats
         * @property {JsonResponse|null} [serverStats] Response serverStats
         */

        /**
         * Constructs a new Response.
         * @exports Response
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response outgoingMessages.
         * @member {OutgoingMessagesResponse|null|undefined} outgoingMessages
         * @memberof Response
         * @instance
         */
        Response.prototype.outgoingMessages = null;

        /**
         * Response channelStats.
         * @member {ChannelStatsResponse|null|undefined} channelStats
         * @memberof Response
         * @instance
         */
        Response.prototype.channelStats = null;

        /**
         * Response serverStats.
         * @member {JsonResponse|null|undefined} serverStats
         * @memberof Response
         * @instance
         */
        Response.prototype.serverStats = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Response command.
         * @member {"outgoingMessages"|"channelStats"|"serverStats"|undefined} command
         * @memberof Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["outgoingMessages", "channelStats", "serverStats"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Response
         * @static
         * @param {IResponse=} [properties] Properties to set
         * @returns {Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Response.verify|verify} messages.
         * @function encode
         * @memberof Response
         * @static
         * @param {Response} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.outgoingMessages != null && message.hasOwnProperty("outgoingMessages"))
                $root.OutgoingMessagesResponse.encode(message.outgoingMessages, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelStats != null && message.hasOwnProperty("channelStats"))
                $root.ChannelStatsResponse.encode(message.channelStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.serverStats != null && message.hasOwnProperty("serverStats"))
                $root.JsonResponse.encode(message.serverStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.outgoingMessages = $root.OutgoingMessagesResponse.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.channelStats = $root.ChannelStatsResponse.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.serverStats = $root.JsonResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Response;
    })();

    $root.OutgoingMessagesResponse = (function() {

        /**
         * Properties of an OutgoingMessagesResponse.
         * @exports IOutgoingMessagesResponse
         * @interface IOutgoingMessagesResponse
         * @property {Array.<OutgoingMessage>|null} [messages] OutgoingMessagesResponse messages
         */

        /**
         * Constructs a new OutgoingMessagesResponse.
         * @exports OutgoingMessagesResponse
         * @classdesc Represents an OutgoingMessagesResponse.
         * @implements IOutgoingMessagesResponse
         * @constructor
         * @param {IOutgoingMessagesResponse=} [properties] Properties to set
         */
        function OutgoingMessagesResponse(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OutgoingMessagesResponse messages.
         * @member {Array.<OutgoingMessage>} messages
         * @memberof OutgoingMessagesResponse
         * @instance
         */
        OutgoingMessagesResponse.prototype.messages = $util.emptyArray;

        /**
         * Creates a new OutgoingMessagesResponse instance using the specified properties.
         * @function create
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {IOutgoingMessagesResponse=} [properties] Properties to set
         * @returns {OutgoingMessagesResponse} OutgoingMessagesResponse instance
         */
        OutgoingMessagesResponse.create = function create(properties) {
            return new OutgoingMessagesResponse(properties);
        };

        /**
         * Encodes the specified OutgoingMessagesResponse message. Does not implicitly {@link OutgoingMessagesResponse.verify|verify} messages.
         * @function encode
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {OutgoingMessagesResponse} message OutgoingMessagesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutgoingMessagesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.OutgoingMessage.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an OutgoingMessagesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OutgoingMessagesResponse} OutgoingMessagesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutgoingMessagesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OutgoingMessagesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.OutgoingMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return OutgoingMessagesResponse;
    })();

    $root.OutgoingMessage = (function() {

        /**
         * Properties of an OutgoingMessage.
         * @exports IOutgoingMessage
         * @interface IOutgoingMessage
         * @property {Uint8Array|null} [id] OutgoingMessage id
         * @property {string|null} [body] OutgoingMessage body
         * @property {number|null} [expiry] OutgoingMessage expiry
         * @property {number|null} [created] OutgoingMessage created
         * @property {Sender|null} [sender] OutgoingMessage sender
         */

        /**
         * Constructs a new OutgoingMessage.
         * @exports OutgoingMessage
         * @classdesc Represents an OutgoingMessage.
         * @implements IOutgoingMessage
         * @constructor
         * @param {IOutgoingMessage=} [properties] Properties to set
         */
        function OutgoingMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OutgoingMessage id.
         * @member {Uint8Array} id
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.id = $util.newBuffer([]);

        /**
         * OutgoingMessage body.
         * @member {string} body
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.body = "";

        /**
         * OutgoingMessage expiry.
         * @member {number} expiry
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.expiry = 0;

        /**
         * OutgoingMessage created.
         * @member {number} created
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.created = 0;

        /**
         * OutgoingMessage sender.
         * @member {Sender|null|undefined} sender
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.sender = null;

        /**
         * Creates a new OutgoingMessage instance using the specified properties.
         * @function create
         * @memberof OutgoingMessage
         * @static
         * @param {IOutgoingMessage=} [properties] Properties to set
         * @returns {OutgoingMessage} OutgoingMessage instance
         */
        OutgoingMessage.create = function create(properties) {
            return new OutgoingMessage(properties);
        };

        /**
         * Encodes the specified OutgoingMessage message. Does not implicitly {@link OutgoingMessage.verify|verify} messages.
         * @function encode
         * @memberof OutgoingMessage
         * @static
         * @param {OutgoingMessage} message OutgoingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutgoingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.body != null && message.hasOwnProperty("body"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.body);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.expiry);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.created);
            if (message.sender != null && message.hasOwnProperty("sender"))
                $root.Sender.encode(message.sender, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an OutgoingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof OutgoingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OutgoingMessage} OutgoingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutgoingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OutgoingMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.body = reader.string();
                    break;
                case 3:
                    message.expiry = reader.uint32();
                    break;
                case 4:
                    message.created = reader.fixed32();
                    break;
                case 5:
                    message.sender = $root.Sender.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return OutgoingMessage;
    })();

    $root.ChannelStatsResponse = (function() {

        /**
         * Properties of a ChannelStatsResponse.
         * @exports IChannelStatsResponse
         * @interface IChannelStatsResponse
         * @property {Array.<ChannelStats>|null} [channels] ChannelStatsResponse channels
         */

        /**
         * Constructs a new ChannelStatsResponse.
         * @exports ChannelStatsResponse
         * @classdesc Represents a ChannelStatsResponse.
         * @implements IChannelStatsResponse
         * @constructor
         * @param {IChannelStatsResponse=} [properties] Properties to set
         */
        function ChannelStatsResponse(properties) {
            this.channels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStatsResponse channels.
         * @member {Array.<ChannelStats>} channels
         * @memberof ChannelStatsResponse
         * @instance
         */
        ChannelStatsResponse.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ChannelStatsResponse instance using the specified properties.
         * @function create
         * @memberof ChannelStatsResponse
         * @static
         * @param {IChannelStatsResponse=} [properties] Properties to set
         * @returns {ChannelStatsResponse} ChannelStatsResponse instance
         */
        ChannelStatsResponse.create = function create(properties) {
            return new ChannelStatsResponse(properties);
        };

        /**
         * Encodes the specified ChannelStatsResponse message. Does not implicitly {@link ChannelStatsResponse.verify|verify} messages.
         * @function encode
         * @memberof ChannelStatsResponse
         * @static
         * @param {ChannelStatsResponse} message ChannelStatsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStatsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (var i = 0; i < message.channels.length; ++i)
                    $root.ChannelStats.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ChannelStatsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStatsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStatsResponse} ChannelStatsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStatsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStatsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.ChannelStats.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStatsResponse;
    })();

    $root.ChannelStats = (function() {

        /**
         * Properties of a ChannelStats.
         * @exports IChannelStats
         * @interface IChannelStats
         * @property {Uint8Array|null} [id] ChannelStats id
         * @property {boolean|null} [isPrivate] ChannelStats isPrivate
         * @property {boolean|null} [isOnline] ChannelStats isOnline
         */

        /**
         * Constructs a new ChannelStats.
         * @exports ChannelStats
         * @classdesc Represents a ChannelStats.
         * @implements IChannelStats
         * @constructor
         * @param {IChannelStats=} [properties] Properties to set
         */
        function ChannelStats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStats id.
         * @member {Uint8Array} id
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.id = $util.newBuffer([]);

        /**
         * ChannelStats isPrivate.
         * @member {boolean} isPrivate
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.isPrivate = false;

        /**
         * ChannelStats isOnline.
         * @member {boolean} isOnline
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.isOnline = false;

        /**
         * Creates a new ChannelStats instance using the specified properties.
         * @function create
         * @memberof ChannelStats
         * @static
         * @param {IChannelStats=} [properties] Properties to set
         * @returns {ChannelStats} ChannelStats instance
         */
        ChannelStats.create = function create(properties) {
            return new ChannelStats(properties);
        };

        /**
         * Encodes the specified ChannelStats message. Does not implicitly {@link ChannelStats.verify|verify} messages.
         * @function encode
         * @memberof ChannelStats
         * @static
         * @param {ChannelStats} message ChannelStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.isOnline != null && message.hasOwnProperty("isOnline"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isOnline);
            return writer;
        };

        /**
         * Decodes a ChannelStats message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStats} ChannelStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.isOnline = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStats;
    })();

    $root.JsonResponse = (function() {

        /**
         * Properties of a JsonResponse.
         * @exports IJsonResponse
         * @interface IJsonResponse
         * @property {string|null} [json] JsonResponse json
         */

        /**
         * Constructs a new JsonResponse.
         * @exports JsonResponse
         * @classdesc Represents a JsonResponse.
         * @implements IJsonResponse
         * @constructor
         * @param {IJsonResponse=} [properties] Properties to set
         */
        function JsonResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JsonResponse json.
         * @member {string} json
         * @memberof JsonResponse
         * @instance
         */
        JsonResponse.prototype.json = "";

        /**
         * Creates a new JsonResponse instance using the specified properties.
         * @function create
         * @memberof JsonResponse
         * @static
         * @param {IJsonResponse=} [properties] Properties to set
         * @returns {JsonResponse} JsonResponse instance
         */
        JsonResponse.create = function create(properties) {
            return new JsonResponse(properties);
        };

        /**
         * Encodes the specified JsonResponse message. Does not implicitly {@link JsonResponse.verify|verify} messages.
         * @function encode
         * @memberof JsonResponse
         * @static
         * @param {JsonResponse} message JsonResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JsonResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.json != null && message.hasOwnProperty("json"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);
            return writer;
        };

        /**
         * Decodes a JsonResponse message from the specified reader or buffer.
         * @function decode
         * @memberof JsonResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {JsonResponse} JsonResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JsonResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.JsonResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.json = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return JsonResponse;
    })();

    return $root;
})(
	typeof window==="object" && typeof window.protobuf==='object' && window.protobuf
	|| typeof self==="object" && typeof self.protobuf==='object' && self.protobuf
	|| typeof protobuf==='object' && protobuf
);
        J x      20240704121409-8lJ rF   https://astralinux.ru/bitrix/js/pull/protobuf/model.js?170345227970928       /*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
(function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

    // Exported root namespace
    var $root = $protobuf.roots["push-server"] || ($protobuf.roots["push-server"] = {});

    $root.RequestBatch = (function() {

        /**
         * Properties of a RequestBatch.
         * @exports IRequestBatch
         * @interface IRequestBatch
         * @property {Array.<Request>|null} [requests] RequestBatch requests
         */

        /**
         * Constructs a new RequestBatch.
         * @exports RequestBatch
         * @classdesc Represents a RequestBatch.
         * @implements IRequestBatch
         * @constructor
         * @param {IRequestBatch=} [properties] Properties to set
         */
        function RequestBatch(properties) {
            this.requests = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestBatch requests.
         * @member {Array.<Request>} requests
         * @memberof RequestBatch
         * @instance
         */
        RequestBatch.prototype.requests = $util.emptyArray;

        /**
         * Creates a new RequestBatch instance using the specified properties.
         * @function create
         * @memberof RequestBatch
         * @static
         * @param {IRequestBatch=} [properties] Properties to set
         * @returns {RequestBatch} RequestBatch instance
         */
        RequestBatch.create = function create(properties) {
            return new RequestBatch(properties);
        };

        /**
         * Encodes the specified RequestBatch message. Does not implicitly {@link RequestBatch.verify|verify} messages.
         * @function encode
         * @memberof RequestBatch
         * @static
         * @param {RequestBatch} message RequestBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestBatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requests != null && message.requests.length)
                for (var i = 0; i < message.requests.length; ++i)
                    $root.Request.encode(message.requests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a RequestBatch message from the specified reader or buffer.
         * @function decode
         * @memberof RequestBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RequestBatch} RequestBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestBatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RequestBatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.requests && message.requests.length))
                        message.requests = [];
                    message.requests.push($root.Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RequestBatch;
    })();

    $root.Request = (function() {

        /**
         * Properties of a Request.
         * @exports IRequest
         * @interface IRequest
         * @property {IncomingMessagesRequest|null} [incomingMessages] Request incomingMessages
         * @property {ChannelStatsRequest|null} [channelStats] Request channelStats
         * @property {ServerStatsRequest|null} [serverStats] Request serverStats
         */

        /**
         * Constructs a new Request.
         * @exports Request
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request incomingMessages.
         * @member {IncomingMessagesRequest|null|undefined} incomingMessages
         * @memberof Request
         * @instance
         */
        Request.prototype.incomingMessages = null;

        /**
         * Request channelStats.
         * @member {ChannelStatsRequest|null|undefined} channelStats
         * @memberof Request
         * @instance
         */
        Request.prototype.channelStats = null;

        /**
         * Request serverStats.
         * @member {ServerStatsRequest|null|undefined} serverStats
         * @memberof Request
         * @instance
         */
        Request.prototype.serverStats = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Request command.
         * @member {"incomingMessages"|"channelStats"|"serverStats"|undefined} command
         * @memberof Request
         * @instance
         */
        Object.defineProperty(Request.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["incomingMessages", "channelStats", "serverStats"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Request
         * @static
         * @param {IRequest=} [properties] Properties to set
         * @returns {Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Request.verify|verify} messages.
         * @function encode
         * @memberof Request
         * @static
         * @param {Request} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.incomingMessages != null && message.hasOwnProperty("incomingMessages"))
                $root.IncomingMessagesRequest.encode(message.incomingMessages, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelStats != null && message.hasOwnProperty("channelStats"))
                $root.ChannelStatsRequest.encode(message.channelStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.serverStats != null && message.hasOwnProperty("serverStats"))
                $root.ServerStatsRequest.encode(message.serverStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.incomingMessages = $root.IncomingMessagesRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.channelStats = $root.ChannelStatsRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.serverStats = $root.ServerStatsRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Request;
    })();

    $root.IncomingMessagesRequest = (function() {

        /**
         * Properties of an IncomingMessagesRequest.
         * @exports IIncomingMessagesRequest
         * @interface IIncomingMessagesRequest
         * @property {Array.<IncomingMessage>|null} [messages] IncomingMessagesRequest messages
         */

        /**
         * Constructs a new IncomingMessagesRequest.
         * @exports IncomingMessagesRequest
         * @classdesc Represents an IncomingMessagesRequest.
         * @implements IIncomingMessagesRequest
         * @constructor
         * @param {IIncomingMessagesRequest=} [properties] Properties to set
         */
        function IncomingMessagesRequest(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingMessagesRequest messages.
         * @member {Array.<IncomingMessage>} messages
         * @memberof IncomingMessagesRequest
         * @instance
         */
        IncomingMessagesRequest.prototype.messages = $util.emptyArray;

        /**
         * Creates a new IncomingMessagesRequest instance using the specified properties.
         * @function create
         * @memberof IncomingMessagesRequest
         * @static
         * @param {IIncomingMessagesRequest=} [properties] Properties to set
         * @returns {IncomingMessagesRequest} IncomingMessagesRequest instance
         */
        IncomingMessagesRequest.create = function create(properties) {
            return new IncomingMessagesRequest(properties);
        };

        /**
         * Encodes the specified IncomingMessagesRequest message. Does not implicitly {@link IncomingMessagesRequest.verify|verify} messages.
         * @function encode
         * @memberof IncomingMessagesRequest
         * @static
         * @param {IncomingMessagesRequest} message IncomingMessagesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingMessagesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.IncomingMessage.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an IncomingMessagesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof IncomingMessagesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {IncomingMessagesRequest} IncomingMessagesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingMessagesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IncomingMessagesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.IncomingMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return IncomingMessagesRequest;
    })();

    $root.IncomingMessage = (function() {

        /**
         * Properties of an IncomingMessage.
         * @exports IIncomingMessage
         * @interface IIncomingMessage
         * @property {Array.<Receiver>|null} [receivers] IncomingMessage receivers
         * @property {Sender|null} [sender] IncomingMessage sender
         * @property {string|null} [body] IncomingMessage body
         * @property {number|null} [expiry] IncomingMessage expiry
         * @property {string|null} [type] IncomingMessage type
         */

        /**
         * Constructs a new IncomingMessage.
         * @exports IncomingMessage
         * @classdesc Represents an IncomingMessage.
         * @implements IIncomingMessage
         * @constructor
         * @param {IIncomingMessage=} [properties] Properties to set
         */
        function IncomingMessage(properties) {
            this.receivers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingMessage receivers.
         * @member {Array.<Receiver>} receivers
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.receivers = $util.emptyArray;

        /**
         * IncomingMessage sender.
         * @member {Sender|null|undefined} sender
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.sender = null;

        /**
         * IncomingMessage body.
         * @member {string} body
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.body = "";

        /**
         * IncomingMessage expiry.
         * @member {number} expiry
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.expiry = 0;

        /**
         * IncomingMessage type.
         * @member {string} type
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.type = "";

        /**
         * Creates a new IncomingMessage instance using the specified properties.
         * @function create
         * @memberof IncomingMessage
         * @static
         * @param {IIncomingMessage=} [properties] Properties to set
         * @returns {IncomingMessage} IncomingMessage instance
         */
        IncomingMessage.create = function create(properties) {
            return new IncomingMessage(properties);
        };

        /**
         * Encodes the specified IncomingMessage message. Does not implicitly {@link IncomingMessage.verify|verify} messages.
         * @function encode
         * @memberof IncomingMessage
         * @static
         * @param {IncomingMessage} message IncomingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.receivers != null && message.receivers.length)
                for (var i = 0; i < message.receivers.length; ++i)
                    $root.Receiver.encode(message.receivers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sender != null && message.hasOwnProperty("sender"))
                $root.Sender.encode(message.sender, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.body != null && message.hasOwnProperty("body"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.body);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expiry);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.type);
            return writer;
        };

        /**
         * Decodes an IncomingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof IncomingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {IncomingMessage} IncomingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IncomingMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.receivers && message.receivers.length))
                        message.receivers = [];
                    message.receivers.push($root.Receiver.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.sender = $root.Sender.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.body = reader.string();
                    break;
                case 4:
                    message.expiry = reader.uint32();
                    break;
                case 5:
                    message.type = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return IncomingMessage;
    })();

    $root.ChannelStatsRequest = (function() {

        /**
         * Properties of a ChannelStatsRequest.
         * @exports IChannelStatsRequest
         * @interface IChannelStatsRequest
         * @property {Array.<ChannelId>|null} [channels] ChannelStatsRequest channels
         */

        /**
         * Constructs a new ChannelStatsRequest.
         * @exports ChannelStatsRequest
         * @classdesc Represents a ChannelStatsRequest.
         * @implements IChannelStatsRequest
         * @constructor
         * @param {IChannelStatsRequest=} [properties] Properties to set
         */
        function ChannelStatsRequest(properties) {
            this.channels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStatsRequest channels.
         * @member {Array.<ChannelId>} channels
         * @memberof ChannelStatsRequest
         * @instance
         */
        ChannelStatsRequest.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ChannelStatsRequest instance using the specified properties.
         * @function create
         * @memberof ChannelStatsRequest
         * @static
         * @param {IChannelStatsRequest=} [properties] Properties to set
         * @returns {ChannelStatsRequest} ChannelStatsRequest instance
         */
        ChannelStatsRequest.create = function create(properties) {
            return new ChannelStatsRequest(properties);
        };

        /**
         * Encodes the specified ChannelStatsRequest message. Does not implicitly {@link ChannelStatsRequest.verify|verify} messages.
         * @function encode
         * @memberof ChannelStatsRequest
         * @static
         * @param {ChannelStatsRequest} message ChannelStatsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStatsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (var i = 0; i < message.channels.length; ++i)
                    $root.ChannelId.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ChannelStatsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStatsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStatsRequest} ChannelStatsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStatsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStatsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.ChannelId.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStatsRequest;
    })();

    $root.ChannelId = (function() {

        /**
         * Properties of a ChannelId.
         * @exports IChannelId
         * @interface IChannelId
         * @property {Uint8Array|null} [id] ChannelId id
         * @property {boolean|null} [isPrivate] ChannelId isPrivate
         * @property {Uint8Array|null} [signature] ChannelId signature
         */

        /**
         * Constructs a new ChannelId.
         * @exports ChannelId
         * @classdesc Represents a ChannelId.
         * @implements IChannelId
         * @constructor
         * @param {IChannelId=} [properties] Properties to set
         */
        function ChannelId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelId id.
         * @member {Uint8Array} id
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.id = $util.newBuffer([]);

        /**
         * ChannelId isPrivate.
         * @member {boolean} isPrivate
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.isPrivate = false;

        /**
         * ChannelId signature.
         * @member {Uint8Array} signature
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new ChannelId instance using the specified properties.
         * @function create
         * @memberof ChannelId
         * @static
         * @param {IChannelId=} [properties] Properties to set
         * @returns {ChannelId} ChannelId instance
         */
        ChannelId.create = function create(properties) {
            return new ChannelId(properties);
        };

        /**
         * Encodes the specified ChannelId message. Does not implicitly {@link ChannelId.verify|verify} messages.
         * @function encode
         * @memberof ChannelId
         * @static
         * @param {ChannelId} message ChannelId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
            return writer;
        };

        /**
         * Decodes a ChannelId message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelId} ChannelId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelId;
    })();

    $root.ServerStatsRequest = (function() {

        /**
         * Properties of a ServerStatsRequest.
         * @exports IServerStatsRequest
         * @interface IServerStatsRequest
         */

        /**
         * Constructs a new ServerStatsRequest.
         * @exports ServerStatsRequest
         * @classdesc Represents a ServerStatsRequest.
         * @implements IServerStatsRequest
         * @constructor
         * @param {IServerStatsRequest=} [properties] Properties to set
         */
        function ServerStatsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ServerStatsRequest instance using the specified properties.
         * @function create
         * @memberof ServerStatsRequest
         * @static
         * @param {IServerStatsRequest=} [properties] Properties to set
         * @returns {ServerStatsRequest} ServerStatsRequest instance
         */
        ServerStatsRequest.create = function create(properties) {
            return new ServerStatsRequest(properties);
        };

        /**
         * Encodes the specified ServerStatsRequest message. Does not implicitly {@link ServerStatsRequest.verify|verify} messages.
         * @function encode
         * @memberof ServerStatsRequest
         * @static
         * @param {ServerStatsRequest} message ServerStatsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerStatsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a ServerStatsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ServerStatsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServerStatsRequest} ServerStatsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerStatsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerStatsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ServerStatsRequest;
    })();

    $root.Sender = (function() {

        /**
         * Properties of a Sender.
         * @exports ISender
         * @interface ISender
         * @property {SenderType|null} [type] Sender type
         * @property {Uint8Array|null} [id] Sender id
         */

        /**
         * Constructs a new Sender.
         * @exports Sender
         * @classdesc Represents a Sender.
         * @implements ISender
         * @constructor
         * @param {ISender=} [properties] Properties to set
         */
        function Sender(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Sender type.
         * @member {SenderType} type
         * @memberof Sender
         * @instance
         */
        Sender.prototype.type = 0;

        /**
         * Sender id.
         * @member {Uint8Array} id
         * @memberof Sender
         * @instance
         */
        Sender.prototype.id = $util.newBuffer([]);

        /**
         * Creates a new Sender instance using the specified properties.
         * @function create
         * @memberof Sender
         * @static
         * @param {ISender=} [properties] Properties to set
         * @returns {Sender} Sender instance
         */
        Sender.create = function create(properties) {
            return new Sender(properties);
        };

        /**
         * Encodes the specified Sender message. Does not implicitly {@link Sender.verify|verify} messages.
         * @function encode
         * @memberof Sender
         * @static
         * @param {Sender} message Sender message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Sender.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id);
            return writer;
        };

        /**
         * Decodes a Sender message from the specified reader or buffer.
         * @function decode
         * @memberof Sender
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Sender} Sender
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Sender.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Sender();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Sender;
    })();

    /**
     * SenderType enum.
     * @exports SenderType
     * @enum {string}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} CLIENT=1 CLIENT value
     * @property {number} BACKEND=2 BACKEND value
     */
    $root.SenderType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "CLIENT"] = 1;
        values[valuesById[2] = "BACKEND"] = 2;
        return values;
    })();

    $root.Receiver = (function() {

        /**
         * Properties of a Receiver.
         * @exports IReceiver
         * @interface IReceiver
         * @property {Uint8Array|null} [id] Receiver id
         * @property {boolean|null} [isPrivate] Receiver isPrivate
         * @property {Uint8Array|null} [signature] Receiver signature
         */

        /**
         * Constructs a new Receiver.
         * @exports Receiver
         * @classdesc Represents a Receiver.
         * @implements IReceiver
         * @constructor
         * @param {IReceiver=} [properties] Properties to set
         */
        function Receiver(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Receiver id.
         * @member {Uint8Array} id
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.id = $util.newBuffer([]);

        /**
         * Receiver isPrivate.
         * @member {boolean} isPrivate
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.isPrivate = false;

        /**
         * Receiver signature.
         * @member {Uint8Array} signature
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new Receiver instance using the specified properties.
         * @function create
         * @memberof Receiver
         * @static
         * @param {IReceiver=} [properties] Properties to set
         * @returns {Receiver} Receiver instance
         */
        Receiver.create = function create(properties) {
            return new Receiver(properties);
        };

        /**
         * Encodes the specified Receiver message. Does not implicitly {@link Receiver.verify|verify} messages.
         * @function encode
         * @memberof Receiver
         * @static
         * @param {Receiver} message Receiver message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Receiver.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
            return writer;
        };

        /**
         * Decodes a Receiver message from the specified reader or buffer.
         * @function decode
         * @memberof Receiver
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Receiver} Receiver
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Receiver.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Receiver();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Receiver;
    })();

    $root.ResponseBatch = (function() {

        /**
         * Properties of a ResponseBatch.
         * @exports IResponseBatch
         * @interface IResponseBatch
         * @property {Array.<Response>|null} [responses] ResponseBatch responses
         */

        /**
         * Constructs a new ResponseBatch.
         * @exports ResponseBatch
         * @classdesc Represents a ResponseBatch.
         * @implements IResponseBatch
         * @constructor
         * @param {IResponseBatch=} [properties] Properties to set
         */
        function ResponseBatch(properties) {
            this.responses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseBatch responses.
         * @member {Array.<Response>} responses
         * @memberof ResponseBatch
         * @instance
         */
        ResponseBatch.prototype.responses = $util.emptyArray;

        /**
         * Creates a new ResponseBatch instance using the specified properties.
         * @function create
         * @memberof ResponseBatch
         * @static
         * @param {IResponseBatch=} [properties] Properties to set
         * @returns {ResponseBatch} ResponseBatch instance
         */
        ResponseBatch.create = function create(properties) {
            return new ResponseBatch(properties);
        };

        /**
         * Encodes the specified ResponseBatch message. Does not implicitly {@link ResponseBatch.verify|verify} messages.
         * @function encode
         * @memberof ResponseBatch
         * @static
         * @param {ResponseBatch} message ResponseBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseBatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.responses != null && message.responses.length)
                for (var i = 0; i < message.responses.length; ++i)
                    $root.Response.encode(message.responses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ResponseBatch message from the specified reader or buffer.
         * @function decode
         * @memberof ResponseBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ResponseBatch} ResponseBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseBatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResponseBatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.responses && message.responses.length))
                        message.responses = [];
                    message.responses.push($root.Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ResponseBatch;
    })();

    $root.Response = (function() {

        /**
         * Properties of a Response.
         * @exports IResponse
         * @interface IResponse
         * @property {OutgoingMessagesResponse|null} [outgoingMessages] Response outgoingMessages
         * @property {ChannelStatsResponse|null} [channelStats] Response channelStats
         * @property {JsonResponse|null} [serverStats] Response serverStats
         */

        /**
         * Constructs a new Response.
         * @exports Response
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response outgoingMessages.
         * @member {OutgoingMessagesResponse|null|undefined} outgoingMessages
         * @memberof Response
         * @instance
         */
        Response.prototype.outgoingMessages = null;

        /**
         * Response channelStats.
         * @member {ChannelStatsResponse|null|undefined} channelStats
         * @memberof Response
         * @instance
         */
        Response.prototype.channelStats = null;

        /**
         * Response serverStats.
         * @member {JsonResponse|null|undefined} serverStats
         * @memberof Response
         * @instance
         */
        Response.prototype.serverStats = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Response command.
         * @member {"outgoingMessages"|"channelStats"|"serverStats"|undefined} command
         * @memberof Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["outgoingMessages", "channelStats", "serverStats"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Response
         * @static
         * @param {IResponse=} [properties] Properties to set
         * @returns {Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Response.verify|verify} messages.
         * @function encode
         * @memberof Response
         * @static
         * @param {Response} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.outgoingMessages != null && message.hasOwnProperty("outgoingMessages"))
                $root.OutgoingMessagesResponse.encode(message.outgoingMessages, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelStats != null && message.hasOwnProperty("channelStats"))
                $root.ChannelStatsResponse.encode(message.channelStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.serverStats != null && message.hasOwnProperty("serverStats"))
                $root.JsonResponse.encode(message.serverStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.outgoingMessages = $root.OutgoingMessagesResponse.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.channelStats = $root.ChannelStatsResponse.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.serverStats = $root.JsonResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Response;
    })();

    $root.OutgoingMessagesResponse = (function() {

        /**
         * Properties of an OutgoingMessagesResponse.
         * @exports IOutgoingMessagesResponse
         * @interface IOutgoingMessagesResponse
         * @property {Array.<OutgoingMessage>|null} [messages] OutgoingMessagesResponse messages
         */

        /**
         * Constructs a new OutgoingMessagesResponse.
         * @exports OutgoingMessagesResponse
         * @classdesc Represents an OutgoingMessagesResponse.
         * @implements IOutgoingMessagesResponse
         * @constructor
         * @param {IOutgoingMessagesResponse=} [properties] Properties to set
         */
        function OutgoingMessagesResponse(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OutgoingMessagesResponse messages.
         * @member {Array.<OutgoingMessage>} messages
         * @memberof OutgoingMessagesResponse
         * @instance
         */
        OutgoingMessagesResponse.prototype.messages = $util.emptyArray;

        /**
         * Creates a new OutgoingMessagesResponse instance using the specified properties.
         * @function create
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {IOutgoingMessagesResponse=} [properties] Properties to set
         * @returns {OutgoingMessagesResponse} OutgoingMessagesResponse instance
         */
        OutgoingMessagesResponse.create = function create(properties) {
            return new OutgoingMessagesResponse(properties);
        };

        /**
         * Encodes the specified OutgoingMessagesResponse message. Does not implicitly {@link OutgoingMessagesResponse.verify|verify} messages.
         * @function encode
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {OutgoingMessagesResponse} message OutgoingMessagesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutgoingMessagesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.OutgoingMessage.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an OutgoingMessagesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OutgoingMessagesResponse} OutgoingMessagesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutgoingMessagesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OutgoingMessagesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.OutgoingMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return OutgoingMessagesResponse;
    })();

    $root.OutgoingMessage = (function() {

        /**
         * Properties of an OutgoingMessage.
         * @exports IOutgoingMessage
         * @interface IOutgoingMessage
         * @property {Uint8Array|null} [id] OutgoingMessage id
         * @property {string|null} [body] OutgoingMessage body
         * @property {number|null} [expiry] OutgoingMessage expiry
         * @property {number|null} [created] OutgoingMessage created
         * @property {Sender|null} [sender] OutgoingMessage sender
         */

        /**
         * Constructs a new OutgoingMessage.
         * @exports OutgoingMessage
         * @classdesc Represents an OutgoingMessage.
         * @implements IOutgoingMessage
         * @constructor
         * @param {IOutgoingMessage=} [properties] Properties to set
         */
        function OutgoingMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OutgoingMessage id.
         * @member {Uint8Array} id
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.id = $util.newBuffer([]);

        /**
         * OutgoingMessage body.
         * @member {string} body
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.body = "";

        /**
         * OutgoingMessage expiry.
         * @member {number} expiry
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.expiry = 0;

        /**
         * OutgoingMessage created.
         * @member {number} created
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.created = 0;

        /**
         * OutgoingMessage sender.
         * @member {Sender|null|undefined} sender
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.sender = null;

        /**
         * Creates a new OutgoingMessage instance using the specified properties.
         * @function create
         * @memberof OutgoingMessage
         * @static
         * @param {IOutgoingMessage=} [properties] Properties to set
         * @returns {OutgoingMessage} OutgoingMessage instance
         */
        OutgoingMessage.create = function create(properties) {
            return new OutgoingMessage(properties);
        };

        /**
         * Encodes the specified OutgoingMessage message. Does not implicitly {@link OutgoingMessage.verify|verify} messages.
         * @function encode
         * @memberof OutgoingMessage
         * @static
         * @param {OutgoingMessage} message OutgoingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutgoingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.body != null && message.hasOwnProperty("body"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.body);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.expiry);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.created);
            if (message.sender != null && message.hasOwnProperty("sender"))
                $root.Sender.encode(message.sender, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an OutgoingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof OutgoingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OutgoingMessage} OutgoingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutgoingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OutgoingMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.body = reader.string();
                    break;
                case 3:
                    message.expiry = reader.uint32();
                    break;
                case 4:
                    message.created = reader.fixed32();
                    break;
                case 5:
                    message.sender = $root.Sender.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return OutgoingMessage;
    })();

    $root.ChannelStatsResponse = (function() {

        /**
         * Properties of a ChannelStatsResponse.
         * @exports IChannelStatsResponse
         * @interface IChannelStatsResponse
         * @property {Array.<ChannelStats>|null} [channels] ChannelStatsResponse channels
         */

        /**
         * Constructs a new ChannelStatsResponse.
         * @exports ChannelStatsResponse
         * @classdesc Represents a ChannelStatsResponse.
         * @implements IChannelStatsResponse
         * @constructor
         * @param {IChannelStatsResponse=} [properties] Properties to set
         */
        function ChannelStatsResponse(properties) {
            this.channels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStatsResponse channels.
         * @member {Array.<ChannelStats>} channels
         * @memberof ChannelStatsResponse
         * @instance
         */
        ChannelStatsResponse.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ChannelStatsResponse instance using the specified properties.
         * @function create
         * @memberof ChannelStatsResponse
         * @static
         * @param {IChannelStatsResponse=} [properties] Properties to set
         * @returns {ChannelStatsResponse} ChannelStatsResponse instance
         */
        ChannelStatsResponse.create = function create(properties) {
            return new ChannelStatsResponse(properties);
        };

        /**
         * Encodes the specified ChannelStatsResponse message. Does not implicitly {@link ChannelStatsResponse.verify|verify} messages.
         * @function encode
         * @memberof ChannelStatsResponse
         * @static
         * @param {ChannelStatsResponse} message ChannelStatsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStatsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (var i = 0; i < message.channels.length; ++i)
                    $root.ChannelStats.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ChannelStatsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStatsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStatsResponse} ChannelStatsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStatsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStatsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.ChannelStats.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStatsResponse;
    })();

    $root.ChannelStats = (function() {

        /**
         * Properties of a ChannelStats.
         * @exports IChannelStats
         * @interface IChannelStats
         * @property {Uint8Array|null} [id] ChannelStats id
         * @property {boolean|null} [isPrivate] ChannelStats isPrivate
         * @property {boolean|null} [isOnline] ChannelStats isOnline
         */

        /**
         * Constructs a new ChannelStats.
         * @exports ChannelStats
         * @classdesc Represents a ChannelStats.
         * @implements IChannelStats
         * @constructor
         * @param {IChannelStats=} [properties] Properties to set
         */
        function ChannelStats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStats id.
         * @member {Uint8Array} id
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.id = $util.newBuffer([]);

        /**
         * ChannelStats isPrivate.
         * @member {boolean} isPrivate
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.isPrivate = false;

        /**
         * ChannelStats isOnline.
         * @member {boolean} isOnline
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.isOnline = false;

        /**
         * Creates a new ChannelStats instance using the specified properties.
         * @function create
         * @memberof ChannelStats
         * @static
         * @param {IChannelStats=} [properties] Properties to set
         * @returns {ChannelStats} ChannelStats instance
         */
        ChannelStats.create = function create(properties) {
            return new ChannelStats(properties);
        };

        /**
         * Encodes the specified ChannelStats message. Does not implicitly {@link ChannelStats.verify|verify} messages.
         * @function encode
         * @memberof ChannelStats
         * @static
         * @param {ChannelStats} message ChannelStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uJint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.isOnline != null && message.hasOwnProperty("isOnline"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isOnline);
            return writer;
        };

        /**
         * Decodes a ChannelStats message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStats} ChannelStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.isOnline = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStats;
    })();

    $root.JsonResponse = (function() {

        /**
         * Properties of a JsonResponse.
         * @exports IJsonResponse
         * @interface IJsonResponse
         * @property {string|null} [json] JsonResponse json
         */

        /**
         * Constructs a new JsonResponse.
         * @exports JsonResponse
         * @classdesc Represents a JsonResponse.
         * @implements IJsonResponse
         * @constructor
         * @param {IJsonResponse=} [properties] Properties to set
         */
        function JsonResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JsonResponse json.
         * @member {string} json
         * @memberof JsonResponse
         * @instance
         */
        JsonResponse.prototype.json = "";

        /**
         * Creates a new JsonResponse instance using the specified properties.
         * @function create
         * @memberof JsonResponse
         * @static
         * @param {IJsonResponse=} [properties] Properties to set
         * @returns {JsonResponse} JsonResponse instance
         */
        JsonResponse.create = function create(properties) {
            return new JsonResponse(properties);
        };

        /**
         * Encodes the specified JsonResponse message. Does not implicitly {@link JsonResponse.verify|verify} messages.
         * @function encode
         * @memberof JsonResponse
         * @static
         * @param {JsonResponse} message JsonResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JsonResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.json != null && message.hasOwnProperty("json"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);
            return writer;
        };

        /**
         * Decodes a JsonResponse message from the specified reader or buffer.
         * @function decode
         * @memberof JsonResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {JsonResponse} JsonResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JsonResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.JsonResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.json = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return JsonResponse;
    })();

    return $root;
})(
	typeof window==="object" && typeof window.protobuf==='object' && window.protobuf
	|| typeof self==="object" && typeof self.protobuf==='object' && self.protobuf
	|| typeof protobuf==='object' && protobuf
);
Y   L          	      $protobuf      I      $Reader     c      Reader     s      $Writer    ?      Writer     Qq4J      $util      9Ig      util   p      $root            roots	      U      push-server
    EU       RequestBatch   [      requests   ~Z
      emptyArray     :	#      create           encode     g8      Request    r      decode     ^_n      incomingMessages   Z      channelStats   	U      serverStats    \      $oneOfFields          command!    s      oneOfGetter"    Qb      oneOfSetter#    %      IncomingMessagesRequest$          ChannelStatsRequest%    p-X      ServerStatsRequest&     7;l      messages'   'Q      IncomingMessage(    9\	      receivers)      "      sender*     h;      body+         expiry,           Receiver-   _\^      Sender.     9B      channels/   K	      ChannelId0      8N	      newBuffer1      D?V	      isPrivate2      eN	      signature4      TZu
      SenderType5     '
      valuesById6     `"E      UNKNOWN7    g      CLIENT8     O$      BACKEND9    o      ResponseBatch:      @l	      responses;      8c      Response<         outgoingMessages=         OutgoingMessagesResponse>         ChannelStatsResponse?   s[      JsonResponse@   \\s[      OutgoingMessageA     fD      createdC    Zm>      ChannelStatsD   +
      isOnlineE   2      windowF           protobufG   \l      selfH   j7H      $root.RequestBatch<I    ^s      $root.Request<J     8`      $root.IncomingMessagesRequest<K     4      $root.IncomingMessage<L           $root.ChannelStatsRequest<M     *      $root.ChannelId<N   2~      $root.ServerStatsRequest<O      \      $root.Sender<P      k      $root.SenderType<Q      _      $root.Receiver<R          $root.ResponseBatch<S   4q      $root.Response<T    {      $root.OutgoingMessagesResponse<U          $root.OutgoingMessage<V     9      $root.ChannelStatsResponse<W    m<s      $root.ChannelStats<X    >83      $root.JsonResponse<    S        S              %,                                                                                                                                                                  %                 *                +                0                5                :                ?                D                I                N      Oc                              P  P  P  P               
  P                P                 #  P               '  P               $  P               /  P               %  P               -  P              5  <                 ,  P               9  P              ;  P                 =  P               @  P               >  P               C  P               ?  P0I$KE           
                     
        &!!S                                     m       1         J               J   
   j         1         J               J      "                     w  `F      @ P4 $P  s'A                   +         J        J        J        J   J           J   9   M   	         m    s  M      m	    s  M
      m    s  M      m    s  M      m    s  M      m    s  M      m    s  M      m    s  M      m    s  M      m    s  M      m    s  M      m    s  M      m    s  M       m!    s  M"      m#    s  M$      m%    s  M&      m'    s  M(      @```N`@	`KhPIj`K  P `K PP `K P `K JP `K P `K P `K }PI `K P `K P `K gP `K P `K OP `K P `K EP `K P `K P `Q   0o   \                          m         J     J   M      m   M      m   M      m	   M
      K	`@)	`@6	`@J	`@^	`%Q                X  X            
               m         J   M      J   M      J   M      J      J      9	     J
   h      i       i      i      s <     J      s <   w    m   M      m   M      m   M      K 	`@(	`@0	`03@;	`% P(PH;PDH	`@U	`@l	`@  	`%Q                   0o   \                          m         J     J   M      m   M      m   M      m	   M
      K	`@)	`@6	`@J	`@^	`%Q                   *                             m         J     J   M      J   M      J      M      J   M      J      M	      m
   M      m   M      m   M      K#	`@+	`@3	`@;	`@C	`@M	`@Z	`@v	`@  	`%Q                   0o   \                          m         J     J   M      m   M      m   M      m	   M
      K	`@)	`@6	`@J	`@^	`%Q                   `                             m         J     J   h    s M      J   M      J     J   h    s M      m   M      m	   M
      m   M      K 	` )PI(	`@0	` 0PI:	`@G	`@^	`@v	`%Q                |   ~|   B                          m         m   M      m   M      m   M      K	`@,	`@=	`@L	`%Q                   %d   w                  
        m         J   M      J     J   h    s M      m   M      m   M	      m
   M      K	`@'	` &PI1	`@>	`@S	`@h	`%Q                   
dN   `                 
        9         J      s           OO        OO        OO   `
`P(	` 	` 	` 	`$Q   Tg                             m         J     J   h    s M      J   M      J     J   h    s M      m   M      m	   M
      m   M      K 	` (PI(	`@0	` /PI:	`@G	`@^	`@v	`%Q                   0o   \                          m         J     J   M      m   M      m   M      m	   M
      K	`@)	`@6	`@J	`@^	`%Q                X  Gt$X            
               m         J   M      J   M      J   M      J      J      9	     J
   h      i       i      i      s <     J      s <   w    m   M      m   M      m   M      K 	`@(	`@0	`03@;	`% P(PH;PDH	`@U	`@l	`@  	`%Q                   0o   \                          m         J     J   M      m   M      m   M      m	   M
      K	`@)	`@6	`@J	`@^	`%Q                  3nv                            m         J     J   h    s M      J      M      J   M      J   M      J   M	      m
   M      m   M      m   M      K"	` /PI*	`@2	`@:	`@B	`@L	`@Y	`@t	`@  	`%Q                   0o   \                          m         J     J   M      m   M      m   M      m	   M
      K	`@)	`@6	`@J	`@^	`%Q                   J                             m         J     J   h    s M      J   M      J   M      m   M      m	   M
      m   M      K 	` ,PI(	`@0	`@:	`@G	`@^	`@v	`%Q                   P{   W                          m         J      M      m   M      m   M      m	   M
      K	`@(	`@5	`@H	`@Z	`%Q                3  `  p        p    p    p    `  p        e  k        @!     "    	  p  
  p    p    `  p    &    p    p    p    `  p    (  )     *  +      p    p    p    `  p    .    p    p    p    `  p  0   1  2    p    p    p    `!  p"  p  #  p  $  p  	  `&  p    0   '  p  (  p  )  p  
  `  @e    6  7  8    `,  p  0   1  2  -  p  .  p  /  p    `1  p    :  2  p  3  p  4  p    `6  p  <      e  k        @!     "    7  p  8  p  9  p    `;  p    &  <  p  =  p  >  p    `@  p  0      *  +  A  )  A  p  B  p  C  p    `E  p    .  F  p  G  p  H  p    `J  p  0   1  D  K  p  L  p  M  p    `O  p     4  P  p  Q  p  R  p    `        	     @  p
    p    p#    p'    p$    p/     p%  %  p-  *  p4  +  p,  0  p9  5  p;  :  p=  ?  p@  D  p>  I  pC  N  p?     `  pE  F  ]  G  X                    )                    H                
    ` 	             ` 	             ` 	             ` 	       I                    ` 	             ` 	             ` 	             ` 	       J                #    ` 	             ` 	             ` 	             ` 	 *      K                '    ` 	             ` 	             ` 	             ` 	 :      L                $    ` 	             ` 	             ` 	             ` 	 E      M                /    ` 	             ` 	             ` 	             ` 	 R      N                %    ` 	             ` 	             ` 	             ` 	 Z      O                -  	  ` 	           	  ` 	           	  ` 	           	  ` 	 f      P        m      Q                ,    ` 	             ` 	             ` 	             ` 	 z      R                9    ` 	             ` 	             ` 	             ` 	       S                ;    ` 	             ` 	             ` 	             ` 	       T                =    ` 	             ` 	             ` 	             ` 	       U                @    ` 	             ` 	             ` 	             ` 	       V                >    ` 	             ` 	             ` 	             ` 	       W                C    ` 	             ` 	             ` 	             ` 	       X                ?    ` 	             ` 	             ` 	             ` 	 H                           d   > \   >    
                      #                                     =    =  4   .            	  
  	  
  A   .                    U   .           2  $  *  $  l                                                 )                       )               $     $     )           !%  /5  %  /5     .            '  (  '  (    )            i+  +  Z+  +    9            -  \/  -  \/  )  9            1  4  1  4  =  9           Z5  L  R5  L  T  &            8  9  t8  9  i  !            *?  v?  ?  v?    1            aA  hE  RA  hE    1            G  L  G  L    1           L  [\  L  [\    *            ?O  [P  #O  [P    %            R  *S  R  *S    5            -U  V  U  V  #  5            Y  /\  Y  /\  7  5           \  m  x\  m  N               ^  _  ^  _  a              c  c  zc  c    +            e  g  e  g    +            -j  fm  j  fm    +           m  y  m  y    )            o  p  o  p    $            ,r  {r  r  {r    4            xt  t  it  t    4            cw  ly  Tw  ly    4           y    y                  {  |  {  |  (              K    <    G  (            C    4    T  (                    i  (                      !            "                      }  y  l  y                  U    U    *              k    k    *                      *           *    "    
  $            B  _  ,  _                        3  /              T    T  @  /                    T  /                   k                      ~                        *                      *                      *             <    <    /                y      *            h    Y      :              b    b  (  :                    <  :           g    _    S  &                s    h  !              D    D    1            /           1            ,  W    W    1             K    K    +              +    +    &                      6                      6            
        2  6           s   k   I  #                    \                        .              '   '   .            x  i    .            %  %   #             	  	                Y  Y   .            2 E # E   .                  
  .          5scpy4      h8(h8(H=,hBW   r    O^partitionKey=%28https%2Castralinux.ru%29,:https://astralinux.ru/bitrix/js/pull/protobuf/model.js?170345227970928 necko:classified 1 strongly-framed 1 security-info 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 request-method GET response-head HTTP/1.1 200 OK
Content-Type: application/javascript; charset=UTF-8
ETag: W/"65889e77-11510"
Server: nginx
Date: Wed, 07 May 2025 07:44:23 GMT
Last-Modified: Sun, 24 Dec 2023 21:11:19 GMT
Expires: Fri, 06 Jun 2025 07:44:23 GMT
Cache-Control: max-age=2592000
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
Referrer-Policy: origin
X-XSS-Protection: 1; mode=block
 original-response-headers Server: nginx
Date: Wed, 29 Jan 2025 04:20:25 GMT
Content-Type: application/javascript; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Last-Modified: Sun, 24 Dec 2023 21:11:19 GMT
ETag: W/"65889e77-11510"
Expires: Fri, 28 Feb 2025 04:20:25 GMT
Cache-Control: max-age=2592000
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
Referrer-Policy: origin
X-XSS-Protection: 1; mode=block
 ctid 2 uncompressed-len 0 net-response-time-onstart 758 net-response-time-onstop 802 alt-data 1;70928,javascript/moz-script-bytecode-20240704121409-8l alt-data-from-child 1  `